{"version":3,"sources":["components/grid/grid.styles.js","components/node/node.styles.js","components/node/node.jsx","algorithms/astar.js","algorithms/djikstra.js","components/Sidebar/Sidebar.js","algorithms/bfirst.js","algorithms/dfirst.js","algorithms/bidirectional.js","components/grid/grid.jsx","utils/makeMaze.js","components/pathfindingVis/pathfindingvis.jsx","App.js","reportWebVitals.js","index.js"],"names":["Row","styled","div","Button","button","visitedUpdate","keyframes","pathUpdate","Node","isVisitedVis","isStart","isEnd","isWall","isPathVis","css","col","row","distance","isVisited","isPath","previousNode","isPressed","onMouseClick","onMouseDown","onMouseEnter","onMouseUp","draggable","onClick","calculateCost","currentNode","node","distanceType","Math","floor","sqrt","pow","abs","max","getNeighbors","grid","ROWS","length","COLS","neighbors","push","calculatePath","endNode","shortestPathNodes","unshift","getNodesInShortestPathOrderAstar","nodesInShortestPathOrder","dijkstra","startNode","visitedNodesInOrder","unvisitedNodes","nodes","sort","nodea","nodeb","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","updateUnvisitedNeighbors","nodeA","nodeB","unvisitedNeighbors","filter","neighbor","getUnvisitedNeighbors","Sidebar","children","style","color","display","flexDirection","justifyContent","alignItems","width","borderRight","getAllNeighbors","getAdjacents","startRow","startCol","endRow","endCol","initGrid","rowSize","colSize","undefined","currRow","initNode","cost","F","G","H","Grid","useState","setGrid","setIsPressed","updatingStart","setUpdatingStart","updatingEnd","setUpdatingEnd","makeMaze","newGrid","ROW","COL","maze","generate","height","i","j","isFinish","generateMaze","handleMouseDown","toggleWall","handleMouseEnter","handleMouseUp","onNodeClick","TypeError","updateStart","updateEnd","useEffect","ResizeObserver","entries","document","getElementById","clientHeight","clientWidth","getGridSize","observe","timer","ms","Promise","res","setTimeout","animateShortestPath","shortestPath","a","animateVisitedNodes","window","alert","visBfs","queue","bfs","visDfs","stack","pop","dfs","visAstar","closedlist","openlist","b","current","nNode","includes","astar","source_visited","sPathNodes","dest_visited","dPathNodes","visBiDir","squeue","dqueue","svisited","dvisited","currsn","currdn","sneighbors","dneighbors","sneighbor","dneighbor","sourcePaths","destPaths","sPathRow","destPathRow","bidirectionalSearch","animateVisitedNodesSource","animateVisitedNodesDest","getNodesInShortestPathOrder","visDjikstra","border","backgroundColor","id","onMouseLeave","borderRadius","resize","overflow","minHeight","minWidth","maxWidth","maxHeight","map","rowIndex","nodeIndex","PathFindingVis","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.1642d151.chunk.js","sourcesContent":["import styled from \"styled-components\";\n\nexport const Row = styled.div`\n\tdisplay: flex;\n`;\n\nexport const Button = styled.button`\n\tcolor: white;\n\tbackground-color: transparent;\n\tpadding: 0.5em 1em;\n\tfont-size: 1.25em;\n\tborder: 3px solid white;\n\tborder-radius: 8px;\n\tfont-weight: 600;\n\tcursor: pointer;\n\toutline: none;\n\t&:hover {\n\t\tcolor: black;\n\t\tbackground-color: white;\n\t}\n\ttransition: all 0.25s linear;\n`;\n","import styled, { keyframes, css } from \"styled-components\";\n\nconst visitedUpdate = keyframes`\n\t0%   { \n\t\ttransform: scale(0.5);\n\t\tbackground: #fffb00;\n\t\tborder-radius: 100%\n\t\t}\n\t50%   {\n\t\tbackground: #fffb00;\n\t}\n\t75%   { \n\t\tbackground: #fffb00;\n\t\ttransform: scale(1);\n\t}\n  100% {\n\t\tborder-radius: 20%\n\t\ttransform: scale(1.05);\n\t\tbackground: #f6fa00;\n\t\t}\n`;\n\nconst pathUpdate = keyframes`\n\t0%   { \n\t\ttransform: scale(0);\n\t\tbackground: #006eff;\n\t\tborder-radius: 100%;\n\t}\n\t50%   { \n\t\ttransform: scale(1.15);\n\t\tbackground: #006eff;\n\t}\n  100% { \n\t\ttransform: scale(1);\n\t\tbackground: #006eff;\n\t\tborder-radius: 20%;\n\t\t}\n`;\nexport const Node = styled.div`\n\ttext-align: center;\n\twidth: 40px;\n\theight: 40px;\n\tborder: 3px solid;\n\tmargin: 0px;\n\tborder-radius: 5px;\n\tcursor: pointer;\n\tbackground: ${({ isVisitedVis, isStart, isEnd, isWall, isPathVis }) => {\n\t\tif (isWall) return \"#303030\";\n\n\t\tif (isStart) return \"#22e03e\";\n\t\tif (isEnd) return \"#ed3124\";\n\t\tif (isPathVis)\n\t\t\treturn css`\n\t\t\t\tbackground-size: 200% 200%;\n\t\t\t\tbackground: #00aaff;\n\t\t\t\tanimation: ${pathUpdate} 250ms linear;\n\t\t\t`;\n\t\tif (isVisitedVis)\n\t\t\treturn css`\n\t\t\t\tbackground-size: 200% 200%;\n\t\t\t\tbackground: #f7ce39;\n\t\t\t\tanimation: ${visitedUpdate} 250ms linear;\n\t\t\t`;\n\t\telse return \"#adadad\";\n\t}};\n\t-webkit-transition: all 100ms linear;\n\t-moz-transition: all 100ms linear;\n\t-o-transition: all 100ms linear;\n\ttransition: all 100ms linear;\n\t&:hover {\n\t\ttransition: transform 50ms ease-in-out;\n\t\ttransform: scale(0.9);\n\t\topacity: 0.5;\n\t}\n\t-webkit-touch-callout: none;\n\t-webkit-user-select: none;\n\t-khtml-user-select: none;\n\t-moz-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none;\n\t-webkit-user-drag: none;\n\t-khtml-user-drag: none;\n\t-moz-user-drag: none;\n\t-o-user-drag: none;\n`;\n","import React from \"react\";\nimport * as styled from \"./node.styles\";\n\nexport default function Node({\n\tcol,\n\trow,\n\tisStart,\n\tisEnd,\n\tdistance,\n\tisVisited,\n\tisWall,\n\tisPath,\n\tisVisitedVis,\n\tpreviousNode,\n\tisPathVis,\n\tisPressed,\n\tonMouseClick,\n\tonMouseDown,\n\tonMouseEnter,\n\tonMouseUp,\n}) {\n\treturn (\n\t\t<styled.Node\n\t\t\tdraggable=\"false\"\n\t\t\tcol={col}\n\t\t\trow={row}\n\t\t\tisEnd={isEnd}\n\t\t\tisStart={isStart}\n\t\t\tisWall={isWall}\n\t\t\tisPath={isPath}\n\t\t\tisVisited={isVisited}\n\t\t\tisVisitedVis={isVisitedVis}\n\t\t\tdistance={distance}\n\t\t\tisPathVis={isPathVis}\n\t\t\tisPressed={isPressed}\n\t\t\tonClick={() => onMouseClick(row, col, isStart, isEnd)}\n\t\t\tonMouseDown={() => onMouseDown(row, col, isStart, isEnd)}\n\t\t\tonMouseEnter={() => onMouseEnter(row, col, isStart, isEnd)}\n\t\t\tonMouseUp={() => onMouseUp(row, col, isStart, isEnd)}></styled.Node>\n\t);\n}\n","export function astar(grid, startNode, endNode) {\n\tconst closedlist = [];\n\tconst openlist = [];\n\tstartNode.cost = {\n\t\tF: 0,\n\t\tG: 0,\n\t\tH: 0,\n\t};\n\topenlist.push(startNode);\n\twhile (!!openlist.length) {\n\t\topenlist.sort((a, b) => a.cost.F - b.cost.F);\n\t\tconst current = openlist.shift();\n\t\tclosedlist.push(current);\n\t\tif (current.isWall) continue;\n\t\tcurrent.isVisited = true;\n\t\tif (current.isEnd) return [closedlist, calculatePath(endNode)];\n\t\tconst neighbors = getNeighbors(grid, current);\n\t\tfor (let i = 0; i < neighbors.length; i++) {\n\t\t\tconst nNode = neighbors[i];\n\t\t\tnNode.isVisited = true;\n\t\t\tif (closedlist.includes(nNode)) continue;\n\t\t\tnNode.cost.G = calculateCost(nNode, startNode, \"E\");\n\t\t\tnNode.cost.H = calculateCost(nNode, endNode, \"E\");\n\t\t\tnNode.cost.F = nNode.cost.G + nNode.cost.H;\n\t\t\tif (!openlist.includes(nNode)) {\n\t\t\t\tnNode.previousNode = current;\n\t\t\t\topenlist.push(nNode);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction calculateCost(currentNode, node, distanceType) {\n\tswitch (distanceType) {\n\t\t// Euclidean Distance\n\t\tcase \"E\":\n\t\t\treturn Math.floor(\n\t\t\t\tMath.sqrt(\n\t\t\t\t\tMath.pow(currentNode.row - node.row, 2) +\n\t\t\t\t\t\tMath.pow(currentNode.col - node.col, 2)\n\t\t\t\t) * 10\n\t\t\t);\n\n\t\t// Manhattan Distance\n\t\tcase \"M\":\n\t\t\treturn (\n\t\t\t\tMath.abs(currentNode.row - node.row) +\n\t\t\t\tMath.abs(currentNode.col - node.col)\n\t\t\t);\n\n\t\t// Diagonal Distance\n\t\tcase \"D\":\n\t\t\treturn Math.max(\n\t\t\t\tMath.abs(currentNode.row - node.row),\n\t\t\t\tMath.abs(currentNode.col - node.col)\n\t\t\t);\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\nfunction getNeighbors(grid, currentNode) {\n\tconst ROWS = grid.length;\n\tconst COLS = grid[0].length;\n\tconst { row, col } = currentNode;\n\tconst neighbors = [];\n\n\t// Top, Left, Right, Bottom Nodes\n\tif (\n\t\trow + 1 >= 0 &&\n\t\trow + 1 < ROWS &&\n\t\tcol >= 0 &&\n\t\tcol < COLS &&\n\t\t!grid[row + 1][col].isWall\n\t) {\n\t\tneighbors.push(grid[row + 1][col]);\n\t}\n\tif (\n\t\trow - 1 >= 0 &&\n\t\trow - 1 < ROWS &&\n\t\tcol >= 0 &&\n\t\tcol < COLS &&\n\t\t!grid[row - 1][col].isWall\n\t) {\n\t\tneighbors.push(grid[row - 1][col]);\n\t}\n\tif (\n\t\trow >= 0 &&\n\t\trow < ROWS &&\n\t\tcol - 1 >= 0 &&\n\t\tcol - 1 < COLS &&\n\t\t!grid[row][col - 1].isWall\n\t) {\n\t\tneighbors.push(grid[row][col - 1]);\n\t}\n\tif (\n\t\trow >= 0 &&\n\t\trow < ROWS &&\n\t\tcol + 1 >= 0 &&\n\t\tcol + 1 < COLS &&\n\t\t!grid[row][col + 1].isWall\n\t) {\n\t\tneighbors.push(grid[row][col + 1]);\n\t}\n\n\treturn neighbors;\n}\n\nfunction calculatePath(endNode) {\n\tconst shortestPathNodes = [];\n\tlet currentNode = endNode;\n\twhile (currentNode !== null) {\n\t\tshortestPathNodes.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn shortestPathNodes;\n}\n\nexport function getNodesInShortestPathOrderAstar(node) {\n\tconst nodesInShortestPathOrder = [];\n\tlet currentNode = node;\n\twhile (currentNode !== null) {\n\t\tnodesInShortestPathOrder.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn nodesInShortestPathOrder;\n}\n","function getAllNodes(grid) {\n\tconst nodes = [];\n\tfor (const row of grid) {\n\t\tfor (const node of row) {\n\t\t\tif (node.isStart === true) {\n\t\t\t\tnode.distance = 0;\n\t\t\t}\n\t\t\tnodes.push(node);\n\t\t}\n\t}\n\tnodes.sort((nodea, nodeb) => (nodea.distance > nodeb.distance ? 1 : -1));\n\treturn nodes;\n}\n\nexport function dijkstra(grid, startNode, endNode) {\n\tconst visitedNodesInOrder = [];\n\tstartNode.distance = 0;\n\tconst unvisitedNodes = getAllNodes(grid);\n\t//Dont use a for loop here itll stop after iterating over all nodes\n\t//Even if you dont find your end node\n\n\twhile (!!unvisitedNodes.length) {\n\t\tsortNodesByDistance(unvisitedNodes);\n\t\tlet closestNode = unvisitedNodes.shift();\n\t\tif (closestNode.isWall === true) continue;\n\t\tif (closestNode.distance === Infinity) return [visitedNodesInOrder];\n\t\tclosestNode.isVisited = true;\n\t\tvisitedNodesInOrder.push(closestNode);\n\t\tif (closestNode.isEnd) return [visitedNodesInOrder];\n\t\tupdateUnvisitedNeighbors(closestNode, grid);\n\t}\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n\tunvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nexport function getNodesInShortestPathOrder(node) {\n\tconst nodesInShortestPathOrder = [];\n\tlet currentNode = node;\n\twhile (currentNode !== null) {\n\t\tnodesInShortestPathOrder.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn nodesInShortestPathOrder;\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n\tconst unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\tfor (const neighbor of unvisitedNeighbors) {\n\t\tneighbor.distance = node.distance + 1;\n\t\tneighbor.previousNode = node;\n\t}\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n\tconst neighbors = [];\n\tconst { col, row } = node;\n\tif (row > 0) neighbors.push(grid[row - 1][col]);\n\tif (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n\tif (col > 0) neighbors.push(grid[row][col - 1]);\n\tif (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n\treturn neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n","export default function Sidebar({ children }) {\n\treturn (\n\t\t<div\n\t\t\tstyle={{\n\t\t\t\tcolor: \"white\",\n\t\t\t\tdisplay: \"flex\",\n\t\t\t\tflexDirection: \"column\",\n\t\t\t\tjustifyContent: \"space-evenly\",\n\t\t\t\talignItems: \"center\",\n\t\t\t\twidth: \"20%\",\n\t\t\t\tborderRight: \"3px solid white\",\n\t\t\t}}>\n\t\t\t{children}\n\t\t</div>\n\t);\n}\n","export function bfs(grid, startNode, endNode) {\n\tconst queue = [];\n\tconst visitedNodesInOrder = [];\n\n\tstartNode.isVisited = true;\n\tqueue.push(startNode);\n\n\twhile (!!queue.length) {\n\t\tlet node = queue.shift();\n\n\t\tif (endNode === node) return [visitedNodesInOrder, calculatePath(endNode)];\n\n\t\tif (node.isWall) continue;\n\n\t\tconst neighbors = getAllNeighbors(grid, node);\n\n\t\tfor (const neighbor of neighbors) {\n\t\t\tneighbor.isVisited = true;\n\t\t\tneighbor.previousNode = node;\n\t\t\tvisitedNodesInOrder.push(neighbor);\n\t\t\tqueue.push(neighbor);\n\t\t}\n\t}\n\n\treturn [visitedNodesInOrder, calculatePath(endNode)];\n}\n\nfunction calculatePath(endNode) {\n\tconst shortestPathNodes = [];\n\tlet currentNode = endNode;\n\twhile (currentNode !== null) {\n\t\tshortestPathNodes.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn shortestPathNodes;\n}\n\nfunction getAllNeighbors(grid = [], node) {\n\tconst ROWS = grid.length;\n\tconst COLS = grid[0].length;\n\n\tconst { row, col } = node;\n\tconst neighbors = [];\n\n\tif (\n\t\trow + 1 >= 0 &&\n\t\trow + 1 < ROWS &&\n\t\tcol >= 0 &&\n\t\tcol < COLS &&\n\t\t!grid[row + 1][col].isVisited &&\n\t\t!grid[row + 1][col].isWall\n\t) {\n\t\tneighbors.push(grid[row + 1][col]);\n\t}\n\tif (\n\t\trow - 1 >= 0 &&\n\t\trow - 1 < ROWS &&\n\t\tcol >= 0 &&\n\t\tcol < COLS &&\n\t\t!grid[row - 1][col].isWall &&\n\t\t!grid[row - 1][col].isVisited\n\t) {\n\t\tneighbors.push(grid[row - 1][col]);\n\t}\n\tif (\n\t\trow >= 0 &&\n\t\trow < ROWS &&\n\t\tcol - 1 >= 0 &&\n\t\tcol - 1 < COLS &&\n\t\t!grid[row][col - 1].isWall &&\n\t\t!grid[row][col - 1].isVisited\n\t) {\n\t\tneighbors.push(grid[row][col - 1]);\n\t}\n\tif (\n\t\trow >= 0 &&\n\t\trow < ROWS &&\n\t\tcol + 1 >= 0 &&\n\t\tcol + 1 < COLS &&\n\t\t!grid[row][col + 1].isWall &&\n\t\t!grid[row][col + 1].isVisited\n\t) {\n\t\tneighbors.push(grid[row][col + 1]);\n\t}\n\n\treturn neighbors;\n}\n","export function dfs(grid, startNode, endNode) {\n\tconst stack = [];\n\tconst visitedNodesInOrder = [];\n\n\tstartNode.isVisited = true;\n\tstack.push(startNode);\n\n\twhile (!!stack.length) {\n\t\tlet node = stack.pop();\n\n\t\tif (endNode === node) return [visitedNodesInOrder, calculatePath(endNode)];\n\n\t\tif (node.isWall) continue;\n\n\t\tconst neighbors = getAllNeighbors(grid, node);\n\n\t\tfor (const neighbor of neighbors) {\n\t\t\tneighbor.isVisited = true;\n\t\t\tneighbor.previousNode = node;\n\t\t\tvisitedNodesInOrder.push(neighbor);\n\t\t\tstack.push(neighbor);\n\t\t}\n\t}\n\n\treturn [visitedNodesInOrder, calculatePath(endNode)];\n}\n\nfunction calculatePath(endNode) {\n\tconst shortestPathNodes = [];\n\tlet currentNode = endNode;\n\twhile (currentNode !== null) {\n\t\tshortestPathNodes.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn shortestPathNodes;\n}\n\nfunction getAllNeighbors(grid = [], node) {\n\tconst ROWS = grid.length;\n\tconst COLS = grid[0].length;\n\n\tconst { row, col } = node;\n\tconst neighbors = [];\n\n\tif (\n\t\trow + 1 >= 0 &&\n\t\trow + 1 < ROWS &&\n\t\tcol >= 0 &&\n\t\tcol < COLS &&\n\t\t!grid[row + 1][col].isVisited &&\n\t\t!grid[row + 1][col].isWall\n\t) {\n\t\tneighbors.push(grid[row + 1][col]);\n\t}\n\tif (\n\t\trow - 1 >= 0 &&\n\t\trow - 1 < ROWS &&\n\t\tcol >= 0 &&\n\t\tcol < COLS &&\n\t\t!grid[row - 1][col].isWall &&\n\t\t!grid[row - 1][col].isVisited\n\t) {\n\t\tneighbors.push(grid[row - 1][col]);\n\t}\n\tif (\n\t\trow >= 0 &&\n\t\trow < ROWS &&\n\t\tcol - 1 >= 0 &&\n\t\tcol - 1 < COLS &&\n\t\t!grid[row][col - 1].isWall &&\n\t\t!grid[row][col - 1].isVisited\n\t) {\n\t\tneighbors.push(grid[row][col - 1]);\n\t}\n\tif (\n\t\trow >= 0 &&\n\t\trow < ROWS &&\n\t\tcol + 1 >= 0 &&\n\t\tcol + 1 < COLS &&\n\t\t!grid[row][col + 1].isWall &&\n\t\t!grid[row][col + 1].isVisited\n\t) {\n\t\tneighbors.push(grid[row][col + 1]);\n\t}\n\n\treturn neighbors;\n}\n","export function bidirectionalSearch(grid, startNode, endNode) {\n\tconst squeue = [];\n\tconst dqueue = [];\n\n\tconst svisited = [],\n\t\tdvisited = [];\n\n\tstartNode.isVisited = true;\n\tstartNode.previousNode = null;\n\tsqueue.push(startNode);\n\n\tendNode.isVisited = true;\n\tendNode.previousNode = null;\n\tdqueue.push(endNode);\n\n\twhile (squeue.length && dqueue.length) {\n\t\tconst currsn = squeue.shift();\n\t\tconst currdn = dqueue.shift();\n\n\t\tconst sneighbors = getAllNeighbors(grid, currsn);\n\t\tconst dneighbors = getAllNeighbors(grid, currdn);\n\n\t\tif (currdn === currsn) break;\n\n\t\tfor (const sneighbor of sneighbors) {\n\t\t\tif (!sneighbor.isVisited) {\n\t\t\t\tsneighbor.isVisited = true;\n\t\t\t\tsneighbor.previousNode = currsn;\n\t\t\t\tsqueue.push(sneighbor);\n\t\t\t\tsvisited.push(sneighbor);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (const dneighbor of dneighbors) {\n\t\t\tif (!dneighbor.isVisited) {\n\t\t\t\tdneighbor.isVisited = true;\n\t\t\t\tdneighbor.previousNode = currdn;\n\t\t\t\tdqueue.push(dneighbor);\n\t\t\t\tdvisited.push(dneighbor);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst sourcePaths = [],\n\t\tdestPaths = [];\n\n\tfor (let i = 0; i < svisited.length; i++)\n\t\tsourcePaths.push(calculatePath(svisited[i]));\n\n\tfor (let i = 0; i < dvisited.length; i++)\n\t\tdestPaths.push(calculatePath(dvisited[i]));\n\n\tfor (let i = sourcePaths.length - 1; i >= 0; i--) {\n\t\tconst sPathRow = sourcePaths[i];\n\t\tconst splast = sPathRow[sPathRow.length - 1];\n\t\tconst neighbors = getAdjacents(grid, splast);\n\t\tfor (const neighbor of neighbors) {\n\t\t\tfor (let j = 0; j < destPaths.length; j++) {\n\t\t\t\tconst destPathRow = destPaths[j];\n\t\t\t\tif (destPathRow.includes(neighbor)) {\n\t\t\t\t\treturn [svisited, dvisited, sPathRow, destPathRow];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction getAdjacents(grid = [], node) {\n\tconst ROWS = grid.length;\n\tconst COLS = grid[0].length;\n\n\tconst { row, col } = node;\n\tconst neighbors = [];\n\n\tif (\n\t\trow + 1 >= 0 &&\n\t\trow + 1 < ROWS &&\n\t\tcol >= 0 &&\n\t\tcol < COLS &&\n\t\t!grid[row + 1][col].isWall\n\t) {\n\t\tneighbors.push(grid[row + 1][col]);\n\t}\n\tif (\n\t\trow - 1 >= 0 &&\n\t\trow - 1 < ROWS &&\n\t\tcol >= 0 &&\n\t\tcol < COLS &&\n\t\t!grid[row - 1][col].isWall\n\t) {\n\t\tneighbors.push(grid[row - 1][col]);\n\t}\n\tif (\n\t\trow >= 0 &&\n\t\trow < ROWS &&\n\t\tcol - 1 >= 0 &&\n\t\tcol - 1 < COLS &&\n\t\t!grid[row][col - 1].isWall\n\t) {\n\t\tneighbors.push(grid[row][col - 1]);\n\t}\n\tif (\n\t\trow >= 0 &&\n\t\trow < ROWS &&\n\t\tcol + 1 >= 0 &&\n\t\tcol + 1 < COLS &&\n\t\t!grid[row][col + 1].isWall\n\t) {\n\t\tneighbors.push(grid[row][col + 1]);\n\t}\n\n\treturn neighbors;\n}\n\nfunction getAllNeighbors(grid = [], node) {\n\tconst ROWS = grid.length;\n\tconst COLS = grid[0].length;\n\n\tconst { row, col } = node;\n\tconst neighbors = [];\n\n\tif (\n\t\trow + 1 >= 0 &&\n\t\trow + 1 < ROWS &&\n\t\tcol >= 0 &&\n\t\tcol < COLS &&\n\t\t!grid[row + 1][col].isVisited &&\n\t\t!grid[row + 1][col].isWall\n\t) {\n\t\tneighbors.push(grid[row + 1][col]);\n\t}\n\tif (\n\t\trow - 1 >= 0 &&\n\t\trow - 1 < ROWS &&\n\t\tcol >= 0 &&\n\t\tcol < COLS &&\n\t\t!grid[row - 1][col].isWall &&\n\t\t!grid[row - 1][col].isVisited\n\t) {\n\t\tneighbors.push(grid[row - 1][col]);\n\t}\n\tif (\n\t\trow >= 0 &&\n\t\trow < ROWS &&\n\t\tcol - 1 >= 0 &&\n\t\tcol - 1 < COLS &&\n\t\t!grid[row][col - 1].isWall &&\n\t\t!grid[row][col - 1].isVisited\n\t) {\n\t\tneighbors.push(grid[row][col - 1]);\n\t}\n\tif (\n\t\trow >= 0 &&\n\t\trow < ROWS &&\n\t\tcol + 1 >= 0 &&\n\t\tcol + 1 < COLS &&\n\t\t!grid[row][col + 1].isWall &&\n\t\t!grid[row][col + 1].isVisited\n\t) {\n\t\tneighbors.push(grid[row][col + 1]);\n\t}\n\n\treturn neighbors;\n}\n\nexport function calculatePath(endNode) {\n\tconst shortestPathNodes = [];\n\tlet currentNode = endNode;\n\twhile (currentNode !== null) {\n\t\tshortestPathNodes.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn shortestPathNodes;\n}\n","import React, { useState, useEffect } from \"react\";\nimport * as styled from \"./grid.styles\";\nimport Node from \"../node/node.jsx\";\nimport {\n\tastar,\n\tgetNodesInShortestPathOrderAstar,\n} from \"../../algorithms/astar\";\nimport {\n\tdijkstra,\n\tgetNodesInShortestPathOrder,\n} from \"../../algorithms/djikstra\";\nimport Sidebar from \"../Sidebar/Sidebar\";\nimport { generateMaze } from \"../../utils/makeMaze\";\nimport { bfs } from \"../../algorithms/bfirst\";\nimport { dfs } from \"../../algorithms/dfirst\";\n\nimport {\n\tbidirectionalSearch,\n\tcalculatePath,\n} from \"../../algorithms/bidirectional\";\n\nlet startRow = 0;\nlet startCol = 0;\nlet endRow = 19;\nlet endCol = 29;\n\nfunction initGrid(rowSize, colSize) {\n\tconst grid = [];\n\tif (rowSize !== undefined && colSize !== undefined) {\n\t\tfor (let row = 0; row < rowSize; row++) {\n\t\t\tconst currRow = [];\n\t\t\tfor (let col = 0; col < colSize; col++) {\n\t\t\t\tcurrRow.push(initNode(col, row));\n\t\t\t}\n\t\t\tgrid.push(currRow);\n\t\t}\n\t} else {\n\t\tfor (let row = 0; row < 20; row++) {\n\t\t\tconst currRow = [];\n\t\t\tfor (let col = 0; col < 30; col++) {\n\t\t\t\tcurrRow.push(initNode(col, row));\n\t\t\t}\n\t\t\tgrid.push(currRow);\n\t\t}\n\t}\n\n\treturn grid;\n}\n\nconst initNode = (col, row) => {\n\treturn {\n\t\tcol,\n\t\trow,\n\t\tisStart: row === startRow && col === startCol,\n\t\tisEnd: row === endRow && col === endCol,\n\t\tdistance: Infinity,\n\t\tisVisited: false,\n\t\tisVisitedVis: false,\n\t\tisWall: false,\n\t\tisPath: false,\n\t\tisPathVis: false,\n\t\tpreviousNode: null,\n\t\tcost: {\n\t\t\tF: Infinity,\n\t\t\tG: Infinity,\n\t\t\tH: Infinity,\n\t\t},\n\t};\n};\n\nexport default function Grid() {\n\tconst [grid, setGrid] = useState([]);\n\tconst [isPressed, setIsPressed] = useState(false);\n\tconst [updatingStart, setUpdatingStart] = useState(false);\n\tconst [updatingEnd, setUpdatingEnd] = useState(false);\n\n\tuseEffect(() => {\n\t\tconst resizeObserver = new ResizeObserver((entries) => {\n\t\t\tgetGridSize();\n\t\t});\n\t\tresizeObserver.observe(document.getElementById(\"grid\"));\n\t}, []);\n\n\tfunction getGridSize() {\n\t\tconst rowSize = Math.floor(\n\t\t\tdocument.getElementById(\"grid\").clientHeight / 47\n\t\t);\n\t\tconst colSize = Math.floor(\n\t\t\tdocument.getElementById(\"grid\").clientWidth / 47\n\t\t);\n\t\tsetGrid(() => initGrid(rowSize, colSize));\n\t}\n\n\tfunction makeMaze() {\n\t\tconst newGrid = generateMaze(grid);\n\t\treturn setGrid([...newGrid]);\n\t}\n\n\tfunction handleMouseDown(row, col) {\n\t\tif (updatingEnd === true || updatingStart === true) {\n\t\t} else {\n\t\t\ttoggleWall(row, col);\n\t\t\tsetIsPressed(true);\n\t\t}\n\t}\n\n\tfunction handleMouseEnter(row, col) {\n\t\tif (updatingEnd === false || updatingStart === false) {\n\t\t\tif (isPressed === true) {\n\t\t\t\ttoggleWall(row, col);\n\t\t\t}\n\t\t} else {\n\t\t}\n\t}\n\tfunction handleMouseUp() {\n\t\tsetIsPressed(false);\n\t}\n\n\tfunction toggleWall(row, col) {\n\t\tconst currentNode = grid[row][col];\n\t\tif (\n\t\t\t!currentNode.isPathVis &&\n\t\t\t!currentNode.isEnd &&\n\t\t\t!currentNode.isStart &&\n\t\t\t!currentNode.isVisitedVis\n\t\t) {\n\t\t\tcurrentNode.isWall = !currentNode.isWall;\n\t\t\tsetGrid([...grid]);\n\t\t}\n\t}\n\n\tfunction startNodeUpdateEventLoop() {\n\t\tsetUpdatingStart(true);\n\t}\n\n\tfunction updateStart(row, col) {\n\t\tconst currentNode = grid[row][col];\n\t\ttry {\n\t\t\tlet startNode = grid[startRow][startCol];\n\t\t} catch (startNode) {\n\t\t\tif (startNode instanceof TypeError) {\n\t\t\t} else {\n\t\t\t\tstartNode.isStart = false;\n\t\t\t}\n\t\t}\n\t\tstartCol = col;\n\t\tstartRow = row;\n\t\tcurrentNode.isStart = !currentNode.isStart;\n\t\tsetUpdatingStart(false);\n\t\tsetGrid([...grid]);\n\t}\n\n\tfunction endNodeUpdateEventLoop() {\n\t\tsetUpdatingEnd(true);\n\t}\n\n\tfunction updateEnd(row, col) {\n\t\tconst currentNode = grid[row][col];\n\t\ttry {\n\t\t\tlet endNode = grid[endRow][endCol];\n\t\t} catch (endNode) {\n\t\t\tif (TypeError) {\n\t\t\t} else {\n\t\t\t\tendNode.isEnd = false;\n\t\t\t\tendNode = grid[(row, col)];\n\t\t\t}\n\t\t}\n\t\tendCol = col;\n\t\tendRow = row;\n\t\tcurrentNode.isEnd = !currentNode.isEnd;\n\t\tsetUpdatingEnd(false);\n\t\tsetGrid([...grid]);\n\t}\n\n\tfunction onNodeClick(row, col, isStart, isEnd) {\n\t\tif (updatingStart === true) {\n\t\t\tupdateStart(row, col);\n\t\t}\n\t\tif (updatingEnd === true) {\n\t\t\tupdateEnd(row, col, isStart, isEnd);\n\t\t}\n\t\treturn {\n\t\t\trow,\n\t\t\tcol,\n\t\t\tisStart,\n\t\t\tisEnd,\n\t\t};\n\t}\n\n\tconst timer = (ms) => new Promise((res) => setTimeout(res, ms));\n\tasync function animateShortestPath(shortestPath, grid) {\n\t\tfor (var i = 0; i < shortestPath.length; i++) {\n\t\t\tlet node = shortestPath[i];\n\t\t\tnode.isPathVis = true;\n\t\t\tsetGrid([...grid]);\n\t\t\tawait timer(5);\n\t\t}\n\t}\n\n\tasync function animateVisitedNodes(\n\t\tvisitedNodesInOrder,\n\t\tgrid,\n\t\tshortestPath,\n\t\tanimateShortestPath\n\t) {\n\t\tif (visitedNodesInOrder !== undefined && visitedNodesInOrder !== null) {\n\t\t\tfor (var i in visitedNodesInOrder[0]) {\n\t\t\t\tconst node = visitedNodesInOrder[0][i];\n\t\t\t\tif (node.isVisited) {\n\t\t\t\t\tnode.isVisitedVis = true;\n\t\t\t\t}\n\t\t\t\tsetGrid([...grid]);\n\t\t\t\tawait timer(10);\n\t\t\t}\n\t\t\tanimateShortestPath(shortestPath, grid);\n\t\t} else {\n\t\t\twindow.alert(\"No viable path found!\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfunction visDjikstra(grid) {\n\t\tconst startNode = grid[startRow][startCol];\n\t\tconst endNode = grid[endRow][endCol];\n\t\tconst visitedNodesInOrder = dijkstra(grid, startNode, endNode);\n\t\tconst shortestPath = getNodesInShortestPathOrder(endNode);\n\t\tanimateVisitedNodes(\n\t\t\tvisitedNodesInOrder,\n\t\t\tgrid,\n\t\t\tshortestPath,\n\t\t\tanimateShortestPath\n\t\t);\n\t}\n\n\tfunction visBfs(grid) {\n\t\tconst startNode = grid[startRow][startCol];\n\t\tconst endNode = grid[endRow][endCol];\n\t\tif (startNode !== undefined && endNode !== undefined) {\n\t\t\tconst visitedNodesInOrder = bfs(grid, startNode, endNode);\n\t\t\tconst shortestPath = getNodesInShortestPathOrderAstar(endNode);\n\t\t\tanimateVisitedNodes(\n\t\t\t\tvisitedNodesInOrder,\n\t\t\t\tgrid,\n\t\t\t\tshortestPath,\n\t\t\t\tanimateShortestPath\n\t\t\t);\n\t\t} else {\n\t\t\twindow.alert(\"Check start/end nodes\");\n\t\t}\n\t}\n\n\tfunction visDfs(grid) {\n\t\tconst startNode = grid[startRow][startCol];\n\t\tconst endNode = grid[endRow][endCol];\n\t\tif (startNode !== undefined && endNode !== undefined) {\n\t\t\tconst visitedNodesInOrder = dfs(grid, startNode, endNode);\n\t\t\tconst shortestPath = getNodesInShortestPathOrderAstar(endNode);\n\t\t\tanimateVisitedNodes(\n\t\t\t\tvisitedNodesInOrder,\n\t\t\t\tgrid,\n\t\t\t\tshortestPath,\n\t\t\t\tanimateShortestPath\n\t\t\t);\n\t\t} else {\n\t\t\twindow.alert(\"Check start/end nodes\");\n\t\t}\n\t}\n\n\tfunction visAstar(grid) {\n\t\tconst startNode = grid[startRow][startCol];\n\t\tconst endNode = grid[endRow][endCol];\n\t\tconst visitedNodesInOrder = astar(grid, startNode, endNode);\n\t\tconst shortestPath = getNodesInShortestPathOrderAstar(endNode);\n\t\tanimateVisitedNodes(\n\t\t\tvisitedNodesInOrder,\n\t\t\tgrid,\n\t\t\tshortestPath,\n\t\t\tanimateShortestPath\n\t\t);\n\t}\n\n\tasync function animateVisitedNodesSource(\n\t\tsource_visited,\n\t\tgrid,\n\t\tsPathNodes,\n\t\tanimateShortestPath\n\t) {\n\t\tif (source_visited !== undefined && source_visited !== null) {\n\t\t\tfor (var i in source_visited[0]) {\n\t\t\t\tconst node = source_visited[0][i];\n\t\t\t\tif (node.isVisited) {\n\t\t\t\t\tnode.isVisitedVis = true;\n\t\t\t\t}\n\t\t\t\tsetGrid([...grid]);\n\t\t\t\tawait timer(10);\n\t\t\t}\n\t\t\tanimateShortestPath(sPathNodes, grid);\n\t\t} else {\n\t\t\twindow.alert(\"No viable path found!\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tasync function animateVisitedNodesDest(\n\t\tdest_visited,\n\t\tgrid,\n\t\tdPathNodes,\n\t\tanimateShortestPath\n\t) {\n\t\tif (dest_visited !== undefined && dest_visited !== null) {\n\t\t\tfor (var i in dest_visited[0]) {\n\t\t\t\tconst node = dest_visited[0][i];\n\t\t\t\tif (node.isVisited) {\n\t\t\t\t\tnode.isVisitedVis = true;\n\t\t\t\t}\n\t\t\t\tsetGrid([...grid]);\n\t\t\t\tawait timer(10);\n\t\t\t}\n\t\t\tanimateShortestPath(dPathNodes, grid);\n\t\t} else {\n\t\t\twindow.alert(\"No viable path found!\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfunction visBiDir(grid) {\n\t\tconst startNode = grid[startRow][startCol];\n\t\tconst endNode = grid[endRow][endCol];\n\t\tconst [\n\t\t\tsource_visited,\n\t\t\tdest_visited,\n\t\t\tsPathNodes,\n\t\t\tdPathNodes,\n\t\t] = bidirectionalSearch(grid, startNode, endNode);\n\t\tanimateVisitedNodesSource(\n\t\t\tsource_visited,\n\t\t\tgrid,\n\t\t\tsPathNodes,\n\t\t\tanimateShortestPath\n\t\t);\n\t\tanimateVisitedNodesDest(\n\t\t\tdest_visited,\n\t\t\tgrid,\n\t\t\tdPathNodes,\n\t\t\tanimateShortestPath\n\t\t);\n\t}\n\n\tfunction clearGrid() {\n\t\tsetGrid(initGrid());\n\t\tsetIsPressed(false);\n\t}\n\n\treturn (\n\t\t<>\n\t\t\t<Sidebar>\n\t\t\t\t<styled.Button onClick={() => visDjikstra(grid)}>\n\t\t\t\t\tDijkstra\n\t\t\t\t</styled.Button>\n\t\t\t\t<styled.Button onClick={() => visAstar(grid)}>A* Search</styled.Button>\n\t\t\t\t<styled.Button onClick={() => visBiDir(grid)}>\n\t\t\t\t\tBi Directional\n\t\t\t\t</styled.Button>\n\t\t\t\t<styled.Button onClick={() => visBfs(grid)}>\n\t\t\t\t\tBreadth First\n\t\t\t\t</styled.Button>\n\t\t\t\t<styled.Button onClick={() => visDfs(grid)}>Depth First</styled.Button>\n\t\t\t\t<hr\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\twidth: \"100%\",\n\t\t\t\t\t\theight: \"0px\",\n\t\t\t\t\t\tborder: \"1px solid white\",\n\t\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\t}}\n\t\t\t\t/>\n\t\t\t\t<styled.Button onClick={() => clearGrid()}>Reset</styled.Button>\n\t\t\t\t<styled.Button onClick={() => startNodeUpdateEventLoop()}>\n\t\t\t\t\tStart\n\t\t\t\t</styled.Button>\n\t\t\t\t<styled.Button onClick={() => endNodeUpdateEventLoop()}>\n\t\t\t\t\tEnd\n\t\t\t\t</styled.Button>\n\t\t\t\t<styled.Button onClick={() => makeMaze(grid)}>Maze</styled.Button>\n\t\t\t</Sidebar>\n\t\t\t<div\n\t\t\t\tstyle={{\n\t\t\t\t\twidth: \"100%\",\n\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\tjustifyContent: \"center\",\n\t\t\t\t\talignItems: \"center\",\n\t\t\t\t}}>\n\t\t\t\t<div\n\t\t\t\t\tid=\"grid\"\n\t\t\t\t\tonMouseLeave={() => setIsPressed(false)}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\twidth: \"95%\",\n\t\t\t\t\t\theight: \"95%\",\n\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\tflexDirection: \"column\",\n\t\t\t\t\t\tjustifyContent: \"center\",\n\t\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\t\tborder: \"3px solid white\",\n\t\t\t\t\t\tborderRadius: \"10px\",\n\t\t\t\t\t\tresize: \"both\",\n\t\t\t\t\t\toverflow: \"hidden\",\n\t\t\t\t\t\tminHeight: \"25%\",\n\t\t\t\t\t\tminWidth: \"25%\",\n\t\t\t\t\t\tmaxWidth: \"95%\",\n\t\t\t\t\t\tmaxHeight: \"95%\",\n\t\t\t\t\t}}>\n\t\t\t\t\t{grid.map((row, rowIndex) => {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<styled.Row key={rowIndex} style={{ display: \"flex\" }}>\n\t\t\t\t\t\t\t\t{row.map((node, nodeIndex) => {\n\t\t\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\t\t\tcol,\n\t\t\t\t\t\t\t\t\t\trow,\n\t\t\t\t\t\t\t\t\t\tisStart,\n\t\t\t\t\t\t\t\t\t\tisEnd,\n\t\t\t\t\t\t\t\t\t\tdistance,\n\t\t\t\t\t\t\t\t\t\tisVisited,\n\t\t\t\t\t\t\t\t\t\tisWall,\n\t\t\t\t\t\t\t\t\t\tisPath,\n\t\t\t\t\t\t\t\t\t\tisPathVis,\n\t\t\t\t\t\t\t\t\t\tisVisitedVis,\n\t\t\t\t\t\t\t\t\t\tpreviousNode,\n\t\t\t\t\t\t\t\t\t} = node;\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t<Node\n\t\t\t\t\t\t\t\t\t\t\tkey={nodeIndex}\n\t\t\t\t\t\t\t\t\t\t\tcol={col}\n\t\t\t\t\t\t\t\t\t\t\trow={row}\n\t\t\t\t\t\t\t\t\t\t\tisEnd={isEnd}\n\t\t\t\t\t\t\t\t\t\t\tisStart={isStart}\n\t\t\t\t\t\t\t\t\t\t\tisWall={isWall}\n\t\t\t\t\t\t\t\t\t\t\tisPath={isPath}\n\t\t\t\t\t\t\t\t\t\t\tisPathVis={isPathVis}\n\t\t\t\t\t\t\t\t\t\t\tisVisited={isVisited}\n\t\t\t\t\t\t\t\t\t\t\tdistance={distance}\n\t\t\t\t\t\t\t\t\t\t\tisVisitedVis={isVisitedVis}\n\t\t\t\t\t\t\t\t\t\t\tpreviousNode={previousNode}\n\t\t\t\t\t\t\t\t\t\t\tisPressed={isPressed}\n\t\t\t\t\t\t\t\t\t\t\tonMouseClick={onNodeClick}\n\t\t\t\t\t\t\t\t\t\t\tonMouseDown={handleMouseDown}\n\t\t\t\t\t\t\t\t\t\t\tonMouseEnter={handleMouseEnter}\n\t\t\t\t\t\t\t\t\t\t\tonMouseUp={handleMouseUp}\n\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t</styled.Row>\n\t\t\t\t\t\t);\n\t\t\t\t\t})}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</>\n\t);\n}\n","import generate from \"@indutny/maze\";\n//https://www.npmjs.com/package/@indutny/maze\n\nexport function generateMaze(grid) {\n\tconst ROW = grid.length;\n\tconst COL = grid[0].length;\n\tconst maze = generate({ width: COL, height: ROW });\n\n\tfor (let i = 0; i < ROW; i++) {\n\t\tfor (let j = 0; j < COL; j++) {\n\t\t\tconst { row, col } = grid[i][j];\n\t\t\tif (grid[i][j].isStart || grid[i][j].isFinish) {\n\t\t\t\tif (row > 0) maze[row - 1][col] = 0;\n\t\t\t\tif (row < ROW - 1) maze[row + 1][col] = 0;\n\t\t\t\tif (col > 0) maze[row][col - 1] = 0;\n\t\t\t\tif (col < COL - 1) maze[row][col + 1] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (let i = 0; i < grid.length; i++) {\n\t\tfor (let j = 0; j < grid[0].length; j++) {\n\t\t\tif (!grid[i][j].isStart && !grid[i][j].isEnd && maze[i][j] === 1) {\n\t\t\t\tgrid[i][j].isWall = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn grid;\n}\n","import Grid from \"../grid/grid\";\nexport default function PathFindingVis() {\n\treturn (\n\t\t<div\n\t\t\tstyle={{\n\t\t\t\tdisplay: \"flex\",\n\t\t\t\tflexDirection: \"row\",\n\t\t\t\theight: \"100vh\",\n\t\t\t\tjustifyContent: \"flex-start\",\n\t\t\t\toverflow: \"hidden\",\n\t\t\t}}>\n\t\t\t<Grid />\n\t\t</div>\n\t);\n}\n","import \"./App.css\";\nimport PathFindingVis from \"./components/pathfindingVis/pathfindingvis\";\nfunction App() {\n\treturn <PathFindingVis />;\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}